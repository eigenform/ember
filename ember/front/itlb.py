
from amaranth import *
from amaranth.lib.enum import *
from amaranth.lib.data import *
from amaranth.lib.wiring import *
from amaranth.lib.coding import *
import amaranth.lib.memory as memory
from amaranth.utils import exact_log2, ceil_log2
from amaranth.back import verilog

from amaranth_soc.wishbone import Interface as WishboneInterface
from amaranth_soc.wishbone import Signature as WishboneSignature

from ember.common import *
from ember.common.lfsr import LFSR
from ember.riscv.paging import *
from ember.param import *


class L1ICacheTLBReadPort(Signature):
    """ L1I TLB read port. """
    class Request(Signature):
        """ A request to L1I TLB to resolve the physical page number
        for the provided virtual page number. 
        """
        def __init__(self, param: L1ICacheParams):
            super().__init__({
                'valid': Out(1),
                'vpn': Out(VirtualPageNumberSv32()),
            })
    class Response(Signature):
        """ A response from the L1I TLB containing a physical page number. """
        def __init__(self, param: L1ICacheParams):
            super().__init__({
                'valid': Out(1),
                'hit': Out(1),
                'pte': Out(PageTableEntrySv32()),
            })

    def __init__(self, param: L1ICacheParams):
        super().__init__({
            'req': Out(self.Request(param)),
            'resp': In(self.Response(param)),
        })


class L1ICacheTLBFillRequest(Signature):
    """ A request to write an entry into the L1I TLB. """
    def __init__(self, param: L1ICacheParams):
        super().__init__({
            'valid': Out(1),
            'pte': Out(PageTableEntrySv32()),
            'vpn': Out(VirtualPageNumberSv32()),
        })


class L1ICacheTLB(Component):
    """ L1 instruction cache TLB (translation lookaside buffer).

    This is a small fully-associative cache for page table entries. 
    Each entry in the TLB associates a virtual page number (VPN) to 
    a page table entry (PTE). 

    Replacement Policy
    ==================
    Currently, the replacement policy is *random*. 
    The index for each fill request is generated by an LFSR. 

    At some point, this will probably be replaced with the tree-based 
    pseudo least-recently used (PLRU) policy.

    Ports
    =====
    fill_req: :class:`L1ICacheTLBFillRequest`
        Fill request

    rp: :class:`L1ICacheTLBReadPort`
        Read port

    """

    def __init__(self, param: L1ICacheParams):
        self.p = param
        self.depth = self.p.tlb.num_entries

        self.lfsr = LFSR(degree=ceil_log2(self.depth))

        signature = Signature({
            "fill_req": In(L1ICacheTLBFillRequest(param)),
            "rp": In(L1ICacheTLBReadPort(param)),
        })
        super().__init__(signature)

    def elaborate(self, platform):
        m = Module()

        # Match signals
        match_arr = Array(
            Signal(name=f"match_arr{i}") 
            for i in range(self.depth)
        )

        # Tag and data arrays.
        # FIXME: These are going be turned into a lot of flipflops..
        data_arr  = Array(
            Signal(PageTableEntrySv32(), name=f"data_arr{i}") 
            for i in range(self.depth)
        )
        tag_arr   = Array(
            Signal(VirtualPageNumberSv32(), name=f"tag_arr{i}") 
            for i in range(self.depth)
        )
        valid_arr = Array(Signal() for i in range(self.depth))

        # Generates a "random" index for allocations/evictions.
        # FIXME: The tree-based PLRU is probably a more reasonable strategy.
        lfsr_en = Signal()
        lfsr_out = Signal(ceil_log2(self.depth))
        m.submodules.lfsr = lfsr = EnableInserter(lfsr_en)(self.lfsr)
        m.d.comb += [ 
            lfsr_out.eq(self.lfsr.value), 
        ]

        # This encoder converts the match signals (one-hot) into an index
        # into the data array. 
        m.submodules.match_encoder = match_encoder = PriorityEncoder(self.depth)
        match_hit  = (~match_encoder.n & self.rp.req.valid)
        match_idx  = match_encoder.o
        match_data = Mux(match_hit, data_arr[match_idx], 0)

        # Default assignment for the response
        m.d.sync += [
            self.rp.resp.valid.eq(self.rp.req.valid),
            self.rp.resp.hit.eq(0),
            self.rp.resp.pte.eq(0),
        ]

        with m.If(self.rp.req.valid):
            # Drive input to all of the comparators
            m.d.comb += [
                match_arr[idx].eq(
                    (tag_arr[idx] == self.rp.req.vpn) & valid_arr[idx]
                )
                for idx in range(self.depth)
            ]
            # Obtain the index of the matching entry (if one exists). 
            m.d.comb += [
                match_encoder.i.eq(Cat(*match_arr))
            ]
            # Data for the matching entry is available on the next cycle.
            m.d.sync += [
                self.rp.resp.hit.eq(match_hit),
                self.rp.resp.pte.eq(match_data),
            ]

        fill_idx = lfsr_out
        m.d.comb += lfsr_en.eq(self.fill_req.valid)
        with m.If(self.fill_req.valid):
            m.d.sync += [
                tag_arr[fill_idx].eq(self.fill_req.vpn),
                data_arr[fill_idx].eq(self.fill_req.pte),
                valid_arr[fill_idx].eq(1),
            ]

        return m


